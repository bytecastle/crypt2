func,lang,mod,syntax,tips,ranking
create dataframe or table or array,R,dplyr,"tibble({col1}=c({val1},{val2}), {col2}=c({val3},{val4}))","In DPLYR we use tibbles, which can be looked at as data frames! It has the same code syntax but instead of tibble() use data.frame()",0
view table,R,dplyr,glimpse({df}),You can also use View(),0
filter rows,R,dplyr,{df} %>% filter({col1}>={value} & {col2}<{value}),This is to filter the observations in a dataset based on values of the columns,
select columns,R,dplyr,"{df} %>% select({col1}, {col2})",Here we can select which columns we want to see,
filter rows and select columns,R,dplyr,"{df} %>% filter({col1}>= {value} & {col2}< {value}) %>% select({col1}, {col2})",We combine selecting observations with selecting columns we want to see,
group data,R,dplyr,"{df} %>% group_by({col1}, {col2})",Grouping data is really useful when you want to summarise data and dont want every single observation from the original dataset. Usually we find group_by goes with summarise functions,
order data in ascending order,R,dplyr,{df} %>% arrange({col1}),,
order data in descending order,R,dplyr,{df} %>% arrange(desc({col1})),,
rename columns,R,dplyr,"{df} %>% rename(new_col_name_{col1} = {col1},new_col_name_{col2} = {col2})",,
remove duplicate rows,R,dplyr,{df} %>% distinct(),,
select rows by position,R,dplyr,{df} %>% slice(10:15),,
select all columns except named column,R,dplyr,"{df} %>% select(-{col1},-{col2})",,
summarise data into single row of values,R,dplyr,{df} %>% summarise(avg = mean({col1})),,
apply summary function to each column,R,dplyr,{df} %>% summarise_each(list(mean = mean)),,
count number of rows with each unique value of variable,R,dplyr,"{df} %>% count({col1},{col2})",,
add a new column to the dataset,R,dplyr,{df} %>% mutate(new_column = 'new value'),,
add a new column and drop the original columns,R,dplyr,{df} %>% transmute(new_column = 'new value'),,
left join,R,dplyr,"{df} %>% left_join(another_df, by = '{col1}')",,
right join,R,dplyr,"{df} %>% right_join(another_df, by = '{col1}')",,
inner join,R,dplyr,"{df} %>% inner_join(another_df, by = '{col1}')",,
full join,R,dplyr,"{df} %>% full_join(another_df, by = '{col1}')",,
semi join,R,dplyr,"{df} %>% semi_join(another_df, by = '{col1}')",,
anti join,R,dplyr,"{df} %>% anti_join(another_df, by = '{col1}')",,
create dataframe or table or array,R,data.table,"data.table({col1}=c({val1},{val2}), {col2}=c({val3},{val4}))","To use DATA.TABLE you first need to convert your data frame into a data.table object. If you forget to do so, no problem errors or warnings will remind you!
If you already have a data frame, you can make it a data.table object by simply writing setDT(df) or as.data.table(df)",
view table,R,data.table,View({df}),,
filter rows,R,data.table,"{df}[{col1} >= {value} & {col2} < {value},]",,
select columns,R,data.table,"{df}[,.({col1}, {col2})]",,
filter rows and select columns,R,data.table,"{df}[{col1} >= {value} & {col2} < {value},][,.({col1}, {col2})]",,
group data,R,data.table,"{df}[,j,by=.({col1}, {col2})]","The j stands for the columns you wish to summarise and is necessary i.e. you will get an error/warning if you write dt[,,by=.(col1)] You need to provide something in place of j",
order data in ascending order,R,data.table,"setorder({df},{col1})",,
order data in descending order,R,data.table,"setorder({df},-{col1})",,
rename columns,R,data.table,"setnames({df},c('{col1}','{col2}'),c('new_col_name_{col1}','new_col_name_{col2}'))",,
remove duplicate rows,R,data.table,unique({df}),,
select rows by position,R,data.table,"{df}[10:15,]",,
select all columns except named column,R,data.table,"{df}[,c(""{col1}"",""{col2}""):= NULL]",,
summarise data into single row of values,R,data.table,"{df}[, .(avg = mean({col1}))]",,
apply summary function to each column,R,data.table,"{df}[, lapply(.SD, mean), .SDcols = c(""{col1}"", ""{col2}"")]",,
count number of rows with each unique value of variable,R,data.table,"uniqueN({df}, by = c(""{col1}"", ""{col2}""))",,
add a new column to the dataset,R,data.table,"{df}[,new_column:='new value']",,
add a new column and drop the original columns,R,data.table,"{df}[,new_column:='new value'][,c(""{col1}"",""{col2}""):= NULL]",,
left join,R,data.table,"{df}[another_df, on = ""{col1}"", names(another_df) := mget(paste0(""i."",names(another_df)))]",,
right join,R,data.table,"another_df[{df}, on = ""{col1}"", names({df}) := mget(paste0(""i."",names({df})))]",,
inner join,R,data.table,"{df}[another_df, on = .({col1} = {col1}), nomatch = 0]",,
full join,R,data.table,"merge({df},another_df,by=""{col1}"",all=TRUE)",,
semi join,R,data.table,"names_cols = names({df}) <br/> {df}[another_df, on = .({col1} = {col1}), nomatch = 0][,..names_cols]",,
anti join,R,data.table,"setDT({df})[!another_df, on = ""a""]",,
create dataframe or table or array,Python,pandas,"pandas.DataFrame(data= [[{val1},{val3}], [{val2},{val4}]],columns=['{col1}', '{col2}'])","Always remember that Python starts with index 0,1,2,.. while R starts with 1,2,... If you want the values of the 1st row, 1st column in Python it's [0,1] while in R it's [1,1]",
view table,Python,pandas,print({df}),,
filter rows,Python,pandas,{df}.query('{col1} >= {value} & {col2} < {value}')       ,,
select columns,Python,pandas,"{df}[['{col1}', '{col2}']]",,
filter rows and select columns,Python,pandas,"{df}.loc[({df}.{col1} >= {value}) & ({df}.{col2} < {value}), ['{col1}', '{col2}']]",,
group data,Python,pandas,"{df}.groupby(by=['{col1}', '{col2}'])",,
order data in ascending order,Python,pandas,df.sort_values('{col1}'),,
order data in descending order,Python,pandas,"df.sort_values('{col1}',ascending=False)",,
rename columns,Python,pandas,"{df}.rename(columns = {'{col1}':'new_col_name_{col1}','{col2}':'new_col_name_{col2}'})",,
remove duplicate rows,Python,pandas,{df}.drop_duplicates(),,
select rows by position,Python,pandas,{df}.iloc[9:14],,
select all columns except named column,Python,pandas,"{df}.drop(columns=['{col1}','{col2}'])",,
summarise data into single row of values,Python,pandas,{df}.{col1}.mean(),,
apply summary function to each column,Python,pandas,{df}.mean(),This returns a Pandas series instead of a dataframe!,
count number of rows with each unique value of variable,Python,pandas,{df}['{col1}'].value_counts(),,
add a new column to the dataset,Python,pandas,{df}['new_column'] = 'new value',,
add a new column and drop the original columns,Python,pandas,{df}['new_column'] = 'new value' <br/> {df}[['new_column']],,
left join,Python,pandas,"pandas.merge({df}, another_df, how='left', on='{col1}')",,
right join,Python,pandas,"pandas.merge({df},another_df, how='right', on='{col1}')",,
inner join,Python,pandas,"pandas.merge({df},another_df, how='inner', on='{col1}')",,
full join,Python,pandas,"pandas.merge({df},another_df, how='outer', on='{col1}')",,
semi join,Python,pandas,{df}[{df}.{col1}.isin(another_df.{col1})],,
anti join,Python,pandas,{df}[~{df}.{col1}.isin(another_df.{col1})],,
create dataframe or table or array,Postgresql,No Library,"create table if not exists {df}( <br/> {col1} type1, <br/> {col2} type2 <br/> ); <br/>
insert into {df}({col1},{col2}) values ({val1},{val2}),({val3},{val4});","In SQL, we have 'tables' but they are in no way different from the appearance of data frames. There are many more options with creating a table in SQL and it would be helpful to have a look at those in official documentation",
view table,Postgresql,No Library,select * <br/> from {df};,"Sometimes tables can be quite large and perhaps you just want a glimpse of what the table looks like. In this case you can add another line after the select statement, LIMIT 50 which will pull only the first 50 observations in the table.",
filter rows,Postgresql,No Library,select * <br/> from {df} <br/> where {col1} >= {value} and {col2}< {value};,,
select columns,Postgresql,No Library,"select {col1},{col2} <br/> from {df};",,
filter rows and select columns,Postgresql,No Library,"select {col1},{col2} <br/> from {df} <br/> where {col1} >= {value} and {col2}< {value};",,
group data,Postgresql,No Library,"select * <br/> from {df} <br/> group by {col1},{col2};",,
order data in ascending order,Postgresql,No Library,select * <br/> from {df} <br/> order by {col1}; ,,
order data in descending order,Postgresql,No Library,select * <br/> from {df} <br/> order by {col1} desc; ,,
rename columns,Postgresql,No Library,"select {col1} as new_col_name_{col1}, {col2} as new_col_name_{col2} <br/> from {df}","In reality, tables in a database should not be altered unless it is a permanent alteration, so what you see is the alternative. However IF you need to alter the names of columns etc. you can use ALTER TABLE table_name RENAME column_name TO new_column_name;",
remove duplicate rows,Postgresql,No Library,select distinct * <br/> from {df} ,,
select rows by position,Postgresql,No Library,select * <br/> from {df} <br/> limit 6 offset 9,,
select all columns except named column,Postgresql,No Library,select col1 <br/> from {df},Unfortunately Postgres is not as flexible as R or Python in this case! You need to write the columns you want in the SELECT statement and omit the ones you don't. Here we select only col1 and omit col2,
summarise data into single row of values,Postgresql,No Library,select avg({col1}) as avg <br/> from {df},,
apply summary function to each column,Postgresql,No Library,select avg({col1}) as avg <br/> from {df},,
count number of rows with each unique value of variable,Postgresql,No Library,"select {col1},{col2},count({col1}) as n_{col1}, count({col2}) as n_{col2} <br/> from {df} <br/> group by {col1},{col2}",,
add a new column to the dataset,Postgresql,No Library,"select *, 'new value' as new_column <br/> from {df}",,
add a new column and drop the original columns,Postgresql,No Library,select 'new value' as new_column <br/> from {df},,
left join,Postgresql,No Library,select * from {df} left join another_df on {df}.{col1} = another_df.{col1},,
right join,Postgresql,No Library,select * from {df} right join another_df on {df}.{col1} = another_df.{col1},,
inner join,Postgresql,No Library,select * from {df} join another_df on {df}.{col1} = another_df.{col1},,
full join,Postgresql,No Library,select * from {df} full join another_df on {df}.{col1} = another_df.{col1},,
semi join,Postgresql,No Library,select * from {df} where exists (select 1 from another_df where {df}.{col1} = another_df.{col1}),,
anti join,Postgresql,No Library,select * from {df} where not exists (select 1 from another_df where {df}.{col1} = another_df.{col1}),,
